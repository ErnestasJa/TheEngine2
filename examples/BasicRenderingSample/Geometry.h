#ifndef SAMPLE_GEOMETRY_H
#define SAMPLE_GEOMETRY_H
#include "glm/glm.hpp"
namespace geom
{
static core::Vector<glm::vec3> CubeVertices = {
    {1.000000, -1.000000, -1.000000},   //
    {-1.000000, 1.000000, -1.000000},   //
    {1.000000, 1.000000, -1.000000},    //
    {-1.000000, 1.000000, 1.000000},    //
    {0.999999, -1.000001, 1.000000},    //
    {1.000000, 0.999999, 1.000000},     //
    {1.000000, 0.999999, 1.000000},     //
    {1.000000, -1.000000, -1.000000},   //
    {1.000000, 1.000000, -1.000000},    //
    {0.999999, -1.000001, 1.000000},    //
    {-1.000000, -1.000000, -1.000000},  //
    {1.000000, -1.000000, -1.000000},   //
    {-1.000000, -1.000000, -1.000000},  //
    {-1.000000, 1.000000, 1.000000},    //
    {-1.000000, 1.000000, -1.000000},   //
    {1.000000, 1.000000, -1.000000},    //
    {-1.000000, 1.000000, 1.000000},    //
    {1.000000, 0.999999, 1.000000},     //
    {1.000000, -1.000000, -1.000000},   //
    {-1.000000, -1.000000, -1.000000},  //
    {-1.000000, 1.000000, -1.000000},   //
    {-1.000000, 1.000000, 1.000000},    //
    {-1.000000, -1.000000, 1.000000},   //
    {0.999999, -1.000001, 1.000000},    //
    {1.000000, 0.999999, 1.000000},     //
    {0.999999, -1.000001, 1.000000},    //
    {1.000000, -1.000000, -1.000000},   //
    {0.999999, -1.000001, 1.000000},    //
    {-1.000000, -1.000000, 1.000000},   //
    {-1.000000, -1.000000, -1.000000},  //
    {-1.000000, -1.000000, -1.000000},  //
    {-1.000000, -1.000000, 1.000000},   //
    {-1.000000, 1.000000, 1.000000},    //
    {1.000000, 1.000000, -1.000000},    //
    {-1.000000, 1.000000, -1.000000},   //
    {-1.000000, 1.000000, 1.000000},    //
};

static core::Vector<glm::vec2> CubeUV = {
    {1.000000, 0.000000},   //
    {0.000000, 1.000000},   //
    {1.000000, 1.000000},   //
    {0.000000, 1.000000},   //
    {1.000000, -0.000000},  //
    {1.000000, 1.000000},   //
    {1.000000, 1.000000},   //
    {0.000000, 0.000000},   //
    {1.000000, 0.000000},   //
    {1.000000, 1.000000},   //
    {0.000000, 0.000000},   //
    {1.000000, 0.000000},   //
    {0.000000, 0.000000},   //
    {1.000000, 1.000000},   //
    {1.000000, 0.000000},   //
    {1.000000, 0.000000},   //
    {0.000000, 1.000000},   //
    {1.000000, 1.000000},   //
    {1.000000, 0.000000},   //
    {0.000000, 0.000000},   //
    {0.000000, 1.000000},   //
    {0.000000, 1.000000},   //
    {-0.000000, 0.000000},  //
    {1.000000, -0.000000},  //
    {1.000000, 1.000000},   //
    {-0.000000, 1.000000},  //
    {0.000000, 0.000000},   //
    {1.000000, 1.000000},   //
    {-0.000000, 1.000000},  //
    {0.000000, 0.000000},   //
    {0.000000, 0.000000},   //
    {0.000000, 1.000000},   //
    {1.000000, 1.000000},   //
    {1.000000, 0.000000},   //
    {0.000000, 0.000000},   //
    {0.000000, 1.000000},   //
};

static core::Vector<glm::vec3> CubeNormals = {
    {-0.000000, -0.000000, -1.000000},  //
    {-0.000000, -0.000000, -1.000000},  //
    {-0.000000, -0.000000, -1.000000},  //
    {0.000000, 0.000000, 1.000000},     //
    {0.000000, 0.000000, 1.000000},     //
    {0.000000, 0.000000, 1.000000},     //
    {1.000000, 0.000000, -0.000000},    //
    {1.000000, 0.000000, -0.000000},    //
    {1.000000, 0.000000, -0.000000},    //
    {-0.000000, -1.000000, -0.000000},  //
    {-0.000000, -1.000000, -0.000000},  //
    {-0.000000, -1.000000, -0.000000},  //
    {-1.000000, -0.000000, 0.000000},   //
    {-1.000000, -0.000000, 0.000000},   //
    {-1.000000, -0.000000, 0.000000},   //
    {0.000001, 1.000000, 0.000001},     //
    {0.000001, 1.000000, 0.000001},     //
    {0.000001, 1.000000, 0.000001},     //
    {0.000000, 0.000000, -1.000000},    //
    {0.000000, 0.000000, -1.000000},    //
    {0.000000, 0.000000, -1.000000},    //
    {0.000000, -0.000000, 1.000000},    //
    {0.000000, -0.000000, 1.000000},    //
    {0.000000, -0.000000, 1.000000},    //
    {1.000000, -0.000001, 0.000001},    //
    {1.000000, -0.000001, 0.000001},    //
    {1.000000, -0.000001, 0.000001},    //
    {-0.000000, -1.000000, 0.000000},   //
    {-0.000000, -1.000000, 0.000000},   //
    {-0.000000, -1.000000, 0.000000},   //
    {-1.000000, -0.000000, -0.000000},  //
    {-1.000000, -0.000000, -0.000000},  //
    {-1.000000, -0.000000, -0.000000},  //
    {-0.000000, 1.000000, 0.000000},    //
    {-0.000000, 1.000000, 0.000000},    //
    {-0.000000, 1.000000, 0.000000},    //
};

static core::Vector<uint32_t> CubeIndices = {
    0,  1,  2,   //
    3,  4,  5,   //
    6,  7,  8,   //
    9,  10, 11,  //
    12, 13, 14,  //
    15, 16, 17,  //
    18, 19, 20,  //
    21, 22, 23,  //
    24, 25, 26,  //
    27, 28, 29,  //
    30, 31, 32,  //
    33, 34, 35,  //
};

static void ComputeTangentsAndBiTangents(
    // inputs
    const core::Vector<uint32_t>& indices,
    const core::Vector<glm::vec3>& vertices, const core::Vector<glm::vec2>& uvs,
    // outputs
    core::Vector<glm::vec3>& tangents, core::Vector<glm::vec3>& bitangents)
{
    tangents.clear();
    bitangents.clear();
    for (int i = 0; i < indices.size(); i += 3) {
        // Shortcuts for vertices
        int i0 = indices[i + 0];
        int i1 = indices[i + 1];
        int i2 = indices[i + 2];

        const glm::vec3& v0 = vertices[i0];
        const glm::vec3& v1 = vertices[i1];
        const glm::vec3& v2 = vertices[i2];

        // Shortcuts for UVs
        const glm::vec2& uv0 = uvs[i0];
        const glm::vec2& uv1 = uvs[i1];
        const glm::vec2& uv2 = uvs[i2];

        // Edges of the triangle : postion delta
        glm::vec3 deltaPos1 = v1 - v0;
        glm::vec3 deltaPos2 = v2 - v0;

        // UV delta
        glm::vec2 deltaUV1 = uv1 - uv0;
        glm::vec2 deltaUV2 = uv2 - uv0;

        float r = 1.0f / (deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x);
        glm::vec3 tangent =
            (deltaPos1 * deltaUV2.y - deltaPos2 * deltaUV1.y) * r;
        glm::vec3 bitangent =
            (deltaPos2 * deltaUV1.x - deltaPos1 * deltaUV2.x) * r;

        tangents.push_back(tangent);
        tangents.push_back(tangent);
        tangents.push_back(tangent);

        // Same thing for binormals
        bitangents.push_back(bitangent);
        bitangents.push_back(bitangent);
        bitangents.push_back(bitangent);
    }
}
}

#endif